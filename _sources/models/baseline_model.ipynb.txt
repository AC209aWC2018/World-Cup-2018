{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Baseline Model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will first build some basic models."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from xgboost import XGBClassifier\n",
    "from sklearn.metrics import accuracy_score\n",
    "from sklearn.linear_model import LogisticRegressionCV\n",
    "from sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n",
    "from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import RandomizedSearchCV, GridSearchCV\n",
    "from predict_test_data import predict_test_data\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "train = pd.read_csv('../data/cleaned/train_final.csv')\n",
    "test = pd.read_csv('../data/cleaned/test_final.csv')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Index(['game_date', 'home_team', 'away_team', 'home_score', 'away_score',\n",
       "       'tournament', 'country', 'neutral', 'overall_diff',\n",
       "       'attack_away_defence_home_diff', 'attack_diff',\n",
       "       'attack_home_defence_away_diff', 'defence_diff', 'midfield_diff',\n",
       "       'rank_diff', 'prestige_diff', 'growth_diff', 'full_age_diff',\n",
       "       'start_age_diff', 'value_euros_millions_diff',\n",
       "       'wage_euros_thousands_diff', 'goalkeeper_overall_diff',\n",
       "       'bup_dribbling_diff', 'bup_passing_diff', 'bup_speed_diff',\n",
       "       'cc_crossing_diff', 'cc_passing_diff', 'cc_shooting_diff',\n",
       "       'd_aggresion_diff', 'd_pressure_diff', 'd_width_diff', 'home_win',\n",
       "       'gdp_diff', 'is_home', 'raw_gdp_diff', 'prev_champ',\n",
       "       'score_past_2_games_diff', 'score_conceded_past_5_games_diff',\n",
       "       'score_past_4_games_diff', 'wins_past_2_games_diff',\n",
       "       'score_past_3_games_diff', 'wins_past_4_games_diff',\n",
       "       'score_conceded_past_3_games_diff', 'score_conceded_past_1_games_diff',\n",
       "       'score_past_1_games_diff', 'score_conceded_past_4_games_diff',\n",
       "       'score_past_5_games_diff', 'wins_home_against_away_3_games',\n",
       "       'wins_past_3_games_diff', 'wins_past_1_games_diff',\n",
       "       'wins_home_against_away_2_games', 'wins_home_against_away_4_games',\n",
       "       'wins_past_5_games_diff', 'wins_home_against_away_5_games',\n",
       "       'wins_home_against_away_1_games', 'score_conceded_past_2_games_diff'],\n",
       "      dtype='object')"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Index(['game_date', 'home_team', 'away_team', 'home_score', 'away_score',\n",
       "       'tournament', 'country', 'neutral', 'overall_diff',\n",
       "       'attack_away_defence_home_diff', 'attack_diff',\n",
       "       'attack_home_defence_away_diff', 'defence_diff', 'midfield_diff',\n",
       "       'rank_diff', 'prestige_diff', 'growth_diff', 'full_age_diff',\n",
       "       'start_age_diff', 'value_euros_millions_diff',\n",
       "       'wage_euros_thousands_diff', 'goalkeeper_overall_diff',\n",
       "       'bup_dribbling_diff', 'bup_passing_diff', 'bup_speed_diff',\n",
       "       'cc_crossing_diff', 'cc_passing_diff', 'cc_shooting_diff',\n",
       "       'd_aggresion_diff', 'd_pressure_diff', 'd_width_diff', 'home_win',\n",
       "       'home_win_no_pk', 'Group', 'gdp_diff', 'is_home', 'raw_gdp_diff',\n",
       "       'prev_champ', 'score_past_2_games_diff',\n",
       "       'score_conceded_past_5_games_diff', 'score_past_4_games_diff',\n",
       "       'wins_past_2_games_diff', 'score_past_3_games_diff',\n",
       "       'wins_past_4_games_diff', 'score_conceded_past_3_games_diff',\n",
       "       'score_conceded_past_1_games_diff', 'score_past_1_games_diff',\n",
       "       'score_conceded_past_4_games_diff', 'score_past_5_games_diff',\n",
       "       'wins_home_against_away_3_games', 'wins_past_3_games_diff',\n",
       "       'wins_past_1_games_diff', 'wins_home_against_away_2_games',\n",
       "       'wins_home_against_away_4_games', 'wins_past_5_games_diff',\n",
       "       'wins_home_against_away_5_games', 'wins_home_against_away_1_games',\n",
       "       'score_conceded_past_2_games_diff'],\n",
       "      dtype='object')"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "test.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Our most basic model would be to just predict the majority class every time. In this case, `home_win` = 1 is the majority class. What are is the training accuracy from just doing this \"prediction\"? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.43806009488666314"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train['home_win'].value_counts()[1] / len(train)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Pretty decent when we have 3 classes. What about the test accuracy? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.421875"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "accuracy_score(test['home_win'], np.ones(len(test)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Still decent. Any model we build should be better than this test accuracy of just guessing.\n",
    "\n",
    "Our baseline model will be pretty simple. We will utilize the differences in FIFA rankings, offense ratings, defense ratings, midfield ratings, overall ratings, and whether the home team is actually playing at home. We will make a train and validation set out of the original train set. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "train = train[['home_win', 'rank_diff', 'attack_diff', 'defence_diff', 'midfield_diff', 'overall_diff']]\n",
    "test = test[['home_win', 'rank_diff', 'attack_diff', 'defence_diff', 'midfield_diff', 'overall_diff']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(14)\n",
    "X_train, X_validation = train_test_split(train, test_size = 0.2)\n",
    "y_train = X_train['home_win'].ravel()\n",
    "X_train = X_train.drop(['home_win'], axis = 1).values\n",
    "y_validation = X_validation['home_win'].ravel()\n",
    "X_validation = X_validation.drop(['home_win'], axis = 1).values\n",
    "y_test = test['home_win'].ravel()\n",
    "X_test = test.drop(['home_win'], axis = 1).values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# stores the score of each model\n",
    "score = {}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will first try out logistic regression. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "lr_model = LogisticRegressionCV(solver = 'lbfgs', max_iter = 5000, cv = 5, multi_class='multinomial').fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Logistic Regression Train Score: 0.5128543177323666\n",
      "Logistic Regression Validation Score: 0.5684210526315789\n"
     ]
    }
   ],
   "source": [
    "score[\"Logistic Regression\"] = {}\n",
    "score[\"Logistic Regression\"][\"model\"] = lr_model\n",
    "score[\"Logistic Regression\"][\"Train Score\"] = lr_model.score(X_train, y_train)\n",
    "score[\"Logistic Regression\"][\"Validation Score\"] = lr_model.score(X_validation, y_validation)\n",
    "\n",
    "print(\"Logistic Regression Train Score: {}\".format(score[\"Logistic Regression\"][\"Train Score\"]))\n",
    "print(\"Logistic Regression Validation Score: {}\".format(score[\"Logistic Regression\"][\"Validation Score\"]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will also try out Linear Discriminant Analysis. However, we need to first check whether the variances across the three outcomes are equal. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>rank_diff</th>\n",
       "      <th>attack_diff</th>\n",
       "      <th>defence_diff</th>\n",
       "      <th>midfield_diff</th>\n",
       "      <th>overall_diff</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>home_win</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>-1</th>\n",
       "      <td>916.793268</td>\n",
       "      <td>40.858572</td>\n",
       "      <td>37.554931</td>\n",
       "      <td>38.133908</td>\n",
       "      <td>31.393396</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>960.540851</td>\n",
       "      <td>47.654088</td>\n",
       "      <td>43.559341</td>\n",
       "      <td>41.798216</td>\n",
       "      <td>36.158215</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>936.866455</td>\n",
       "      <td>49.295727</td>\n",
       "      <td>43.509512</td>\n",
       "      <td>42.634416</td>\n",
       "      <td>37.105145</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "           rank_diff  attack_diff  defence_diff  midfield_diff  overall_diff\n",
       "home_win                                                                    \n",
       "-1        916.793268    40.858572     37.554931      38.133908     31.393396\n",
       " 0        960.540851    47.654088     43.559341      41.798216     36.158215\n",
       " 1        936.866455    49.295727     43.509512      42.634416     37.105145"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train.groupby('home_win').var()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Surprisingly, besides `rank_diff`, they are actually quite similar! "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "lda_model = LinearDiscriminantAnalysis().fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "LDA Train Score: 0.5102175346077785\n",
      "LDA Validation Score: 0.5578947368421052\n"
     ]
    }
   ],
   "source": [
    "score[\"LDA\"] = {}\n",
    "score[\"LDA\"][\"model\"] = lda_model\n",
    "score[\"LDA\"][\"Train Score\"] = lda_model.score(X_train, y_train)\n",
    "score[\"LDA\"][\"Validation Score\"] = lda_model.score(X_validation, y_validation)\n",
    "print(\"LDA Train Score: {}\".format(score[\"LDA\"][\"Train Score\"]))\n",
    "print(\"LDA Validation Score: {}\".format(score[\"LDA\"][\"Validation Score\"]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will also try out Quadratic Discriminant Analysis, which should perform similarly to LDA in this case due to the almost equal variances."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "qda_model = QuadraticDiscriminantAnalysis().fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "QDA Train Score: 0.5102175346077785\n",
      "QDA Validation Score: 0.5368421052631579\n"
     ]
    }
   ],
   "source": [
    "score[\"QDA\"] = {}\n",
    "score[\"QDA\"]['model'] = qda_model\n",
    "score[\"QDA\"][\"Train Score\"] = qda_model.score(X_train, y_train)\n",
    "score[\"QDA\"][\"Validation Score\"] = qda_model.score(X_validation, y_validation)\n",
    "print(\"QDA Train Score: {}\".format(score[\"QDA\"][\"Train Score\"]))\n",
    "print(\"QDA Validation Score: {}\".format(score[\"QDA\"][\"Validation Score\"]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will also try out Random Forest."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 50 candidates, totalling 250 fits\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed:    5.9s\n",
      "[Parallel(n_jobs=-1)]: Done 192 tasks      | elapsed:   20.9s\n",
      "[Parallel(n_jobs=-1)]: Done 250 out of 250 | elapsed:   27.9s finished\n"
     ]
    }
   ],
   "source": [
    "rf_params = {'bootstrap': [True, False],\n",
    "     'max_depth': [3, 5, 10, 20, 30, 40, None],\n",
    "'max_features': ['auto', 'sqrt'],\n",
    " 'min_samples_leaf': [1, 2, 4, 10, 20],\n",
    " 'min_samples_split': [2, 5, 10],\n",
    " 'n_estimators': [10, 50, 100, 200, 500]}\n",
    "\n",
    "rf_model = RandomizedSearchCV(estimator=RandomForestClassifier(), param_distributions=rf_params,\\\n",
    "                                   n_iter=50, scoring='accuracy', n_jobs=-1, cv=5, verbose=1).fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Random Forest Train Score: 0.5115359261700725\n",
      "Random Forest Validation Score 0.5552631578947368\n"
     ]
    }
   ],
   "source": [
    "score[\"Random Forest\"] = {}\n",
    "score[\"Random Forest\"]['model'] = rf_model\n",
    "score[\"Random Forest\"][\"Train Score\"] = rf_model.score(X_train, y_train)\n",
    "score[\"Random Forest\"][\"Validation Score\"] = rf_model.score(X_validation, y_validation)\n",
    "print(\"Random Forest Train Score: {}\".format(score[\"Random Forest\"][\"Train Score\"]))\n",
    "print(\"Random Forest Validation Score {}\".format(score[\"Random Forest\"][\"Validation Score\"]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's also not forget XGBoost."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fitting 5 folds for each of 50 candidates, totalling 250 fits\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers.\n",
      "[Parallel(n_jobs=-1)]: Done  42 tasks      | elapsed:    3.5s\n",
      "[Parallel(n_jobs=-1)]: Done 192 tasks      | elapsed:   16.7s\n",
      "[Parallel(n_jobs=-1)]: Done 250 out of 250 | elapsed:   21.0s finished\n"
     ]
    }
   ],
   "source": [
    "xgb_params = {\n",
    "    'min_child_weight': [1, 5, 10],\n",
    "    'gamma': [0.5, 1, 1.5, 2, 5],\n",
    "    'subsample': [0.6, 0.8, 1.0],\n",
    "    'colsample_bytree': [0.6, 0.8, 1.0],\n",
    "    'max_depth': [3, 4, 5]\n",
    "    }\n",
    "xgb_model = RandomizedSearchCV(estimator=XGBClassifier(objective='multi:softmax', num_class = 3), param_distributions=xgb_params,\\\n",
    "                                   n_iter=50, scoring='accuracy', n_jobs=-1, cv=5, verbose=1).fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "XGBoost Train Score: 0.5115359261700725\n",
      "XGBoost Validation Score 0.5552631578947368\n"
     ]
    }
   ],
   "source": [
    "score[\"XGBoost\"] = {}\n",
    "score[\"XGBoost\"]['model'] = xgb_model\n",
    "score[\"XGBoost\"][\"Train Score\"] = xgb_model.score(X_train, y_train)\n",
    "score[\"XGBoost\"][\"Validation Score\"] = xgb_model.score(X_validation, y_validation)\n",
    "print(\"XGBoost Train Score: {}\".format(score[\"Random Forest\"][\"Train Score\"]))\n",
    "print(\"XGBoost Validation Score {}\".format(score[\"Random Forest\"][\"Validation Score\"]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_result = pd.DataFrame(score).T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Train Score</th>\n",
       "      <th>Validation Score</th>\n",
       "      <th>model</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>Logistic Regression</th>\n",
       "      <td>0.512854</td>\n",
       "      <td>0.568421</td>\n",
       "      <td>LogisticRegressionCV(Cs=10, class_weight=None,...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>LDA</th>\n",
       "      <td>0.510218</td>\n",
       "      <td>0.557895</td>\n",
       "      <td>LinearDiscriminantAnalysis(n_components=None, ...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>QDA</th>\n",
       "      <td>0.510218</td>\n",
       "      <td>0.536842</td>\n",
       "      <td>QuadraticDiscriminantAnalysis(priors=None, reg...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>Random Forest</th>\n",
       "      <td>0.511536</td>\n",
       "      <td>0.555263</td>\n",
       "      <td>RandomizedSearchCV(cv=5, error_score='raise-de...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>XGBoost</th>\n",
       "      <td>0.509558</td>\n",
       "      <td>0.557895</td>\n",
       "      <td>RandomizedSearchCV(cv=5, error_score='raise-de...</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "                    Train Score Validation Score  \\\n",
       "Logistic Regression    0.512854         0.568421   \n",
       "LDA                    0.510218         0.557895   \n",
       "QDA                    0.510218         0.536842   \n",
       "Random Forest          0.511536         0.555263   \n",
       "XGBoost                0.509558         0.557895   \n",
       "\n",
       "                                                                 model  \n",
       "Logistic Regression  LogisticRegressionCV(Cs=10, class_weight=None,...  \n",
       "LDA                  LinearDiscriminantAnalysis(n_components=None, ...  \n",
       "QDA                  QuadraticDiscriminantAnalysis(priors=None, reg...  \n",
       "Random Forest        RandomizedSearchCV(cv=5, error_score='raise-de...  \n",
       "XGBoost              RandomizedSearchCV(cv=5, error_score='raise-de...  "
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "We choose the final model to be the one with the highest validation score, which is Logistic Regression in this case\n"
     ]
    }
   ],
   "source": [
    "model_name = df_result['Validation Score'].astype(float).argmax()\n",
    "print(\"We choose the final model to be the one with the highest validation score,\\\n",
    " which is {} in this case\".format(model_name))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "For the best Model, Logistic Regression, the test accuracy is 0.594\n"
     ]
    }
   ],
   "source": [
    "test_pred = predict_test_data(X_test, df_result.loc[model_name].model)\n",
    "test_score = accuracy_score(y_test, test_pred)\n",
    "print(\"For the best Model, {}, the test accuracy is {:.3f}\".format(model_name, test_score))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Impressive! We now have an idea of what our more advanced model should hope to achieve. \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "More importantly, we are curious just how important each feature is, especially the FIFA ranking feature, the one feature we are trying to replace. Feature importance of random forest allows us exactly to do so, and since it has similar performance to logistic regression in the train/validation set, we can utilize it in this case."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "columns = np.array(['rank_diff', 'attack_diff', 'defence_diff', 'midfield_diff', 'overall_diff'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "feature_importances = rf_model.best_estimator_.feature_importances_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "indices = np.argsort(feature_importances)[::-1]\n",
    "plt.title(\"RF Feature Importances\")\n",
    "plt.bar(range(len(columns)), feature_importances[indices],\n",
    "       color=\"r\", align=\"center\")\n",
    "plt.xticks(range(len(columns)), columns[indices], rotation = 90)\n",
    "plt.ylabel('Feature Importances')\n",
    "plt.xlim([-1, len(columns)]);\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It seems like the FIFA rankings is not that important of a feature! Hopefully we can make a better model than the baseline model."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
